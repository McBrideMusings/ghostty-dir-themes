#!/usr/bin/env python3
"""ghostty-dir-themes (gdt) - TUI for managing per-directory Ghostty color themes."""

import argparse
import curses
import json
import logging
import os
import select
import sys
import subprocess
import glob
import random
import shutil
import termios
import tarfile
import tempfile
import threading
import tty
import urllib.error
import urllib.request

VERSION = "0.1.0"

CONFIG_DIR = os.environ.get("GDT_CONFIG_DIR") or os.path.join(
    os.environ.get("XDG_CONFIG_HOME", os.path.expanduser("~/.config")), "gdt"
)
MAPPINGS_FILE = os.path.join(CONFIG_DIR, "mappings.json")
HOOK_FILE = os.path.join(CONFIG_DIR, "hook.zsh")
LOG_FILE = os.path.join(CONFIG_DIR, "gdt.log")
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))

# --- Logging setup ---
os.makedirs(CONFIG_DIR, exist_ok=True)
log = logging.getLogger("gdt")
log.setLevel(logging.DEBUG)
_log_handler = logging.FileHandler(LOG_FILE)
_log_handler.setFormatter(logging.Formatter("%(asctime)s  %(message)s", datefmt="%Y-%m-%d %H:%M:%S"))
log.addHandler(_log_handler)

if sys.platform == "darwin":
    GHOSTTY_BUILTIN_THEMES = "/Applications/Ghostty.app/Contents/Resources/ghostty/themes"
elif sys.platform.startswith("linux"):
    GHOSTTY_BUILTIN_THEMES = "/usr/share/ghostty/themes"
else:
    GHOSTTY_BUILTIN_THEMES = ""
GHOSTTY_USER_THEMES = os.path.expanduser("~/.config/ghostty/themes")
THEMES_TARBALL_URL = "https://github.com/mbadolato/iTerm2-Color-Schemes/archive/refs/heads/master.tar.gz"


def maybe_migrate():
    """Migrate mappings.json from old script-dir location to XDG config dir."""
    old_mappings = os.path.join(SCRIPT_DIR, "mappings.json")
    if os.path.exists(old_mappings) and not os.path.exists(MAPPINGS_FILE):
        os.makedirs(CONFIG_DIR, exist_ok=True)
        shutil.copy2(old_mappings, MAPPINGS_FILE)
        print(f"Migrated mappings.json to {MAPPINGS_FILE}")
        print(f"Update your .zshrc to: source {HOOK_FILE}")


def load_json(path, default=None):
    if default is None:
        default = {}
    try:
        with open(path) as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return default


def save_json(path, data):
    with open(path, "w") as f:
        json.dump(data, f, indent=2)
        f.write("\n")


def parse_theme_file(path):
    """Parse a Ghostty theme file (key=value format) into a dict."""
    theme = {}
    palette = {}
    try:
        with open(path) as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" not in line:
                    continue
                key, _, value = line.partition("=")
                key, value = key.strip(), value.strip()
                if key == "palette":
                    idx, _, color = value.partition("=")
                    palette[int(idx)] = color
                elif key == "background":
                    theme["background"] = value
                elif key == "foreground":
                    theme["foreground"] = value
                elif key == "cursor-color":
                    theme["cursor-color"] = value
                elif key == "selection-background":
                    theme["selection-background"] = value
                elif key == "selection-foreground":
                    theme["selection-foreground"] = value
    except (IOError, OSError):
        return None
    if not theme.get("background") or not theme.get("foreground"):
        return None
    if palette:
        theme["palette"] = palette
    return theme


def discover_themes():
    """Scan Ghostty built-in and user theme directories."""
    themes = {}
    for theme_dir in (GHOSTTY_BUILTIN_THEMES, GHOSTTY_USER_THEMES):
        if not os.path.isdir(theme_dir):
            continue
        for entry in os.listdir(theme_dir):
            path = os.path.join(theme_dir, entry)
            if not os.path.isfile(path):
                continue
            theme = parse_theme_file(path)
            if theme:
                themes[entry] = theme
    return themes


def _cleanup_tmp(path):
    """Remove a temporary file, ignoring errors."""
    try:
        os.unlink(path)
    except OSError:
        pass


def fetch_themes():
    """Download Ghostty themes from GitHub and install to user themes directory."""
    dest = GHOSTTY_USER_THEMES
    os.makedirs(dest, exist_ok=True)

    tmp_path = None
    try:
        # Download tarball to a temp file
        tmp_fd, tmp_path = tempfile.mkstemp(suffix=".tar.gz")
        os.close(tmp_fd)

        print(f"Downloading themes from GitHub...")
        try:
            req = urllib.request.Request(THEMES_TARBALL_URL)
            resp = urllib.request.urlopen(req, timeout=30)
        except urllib.error.URLError as e:
            print(f"Error: could not download themes: {e}")
            return
        except OSError as e:
            print(f"Error: network failure: {e}")
            return

        total = resp.headers.get("Content-Length")
        total = int(total) if total else None

        downloaded = 0
        with open(tmp_path, "wb") as f:
            while True:
                chunk = resp.read(8192)
                if not chunk:
                    break
                f.write(chunk)
                downloaded += len(chunk)
                if total:
                    pct = downloaded * 100 // total
                    bar_len = 30
                    filled = bar_len * downloaded // total
                    bar = "█" * filled + "░" * (bar_len - filled)
                    sys.stdout.write(f"\r  [{bar}] {pct}% ({downloaded // 1024}/{total // 1024} KB)")
                else:
                    sys.stdout.write(f"\r  Downloaded {downloaded // 1024} KB...")
                sys.stdout.flush()
        print()

        # Extract ghostty/ theme files from tarball
        try:
            tf = tarfile.open(tmp_path, "r:gz")
        except (tarfile.TarError, OSError) as e:
            print(f"Error: corrupt or unreadable tarball: {e}")
            return

        installed = 0
        with tf:
            for member in tf.getmembers():
                if not member.isfile():
                    continue
                # Files are under <repo-name>/ghostty/<theme-name>
                parts = member.name.split("/")
                if len(parts) < 3 or parts[1] != "ghostty":
                    continue
                theme_name = parts[-1]
                # Sanitize: reject path traversal attempts
                if "/" in theme_name or theme_name.startswith("."):
                    continue
                out_path = os.path.join(dest, theme_name)
                fobj = tf.extractfile(member)
                if fobj is None:
                    continue
                with open(out_path, "wb") as out:
                    out.write(fobj.read())
                installed += 1

        display_dest = dest.replace(os.path.expanduser("~"), "~")
        log.info("fetch themes  installed=%d  dest=%s", installed, display_dest)
        print(f"Installed {installed} themes to {display_dest}")

    except OSError as e:
        print(f"Error: {e}")
    finally:
        if tmp_path:
            _cleanup_tmp(tmp_path)


def load_mappings():
    return load_json(MAPPINGS_FILE, default=[])


def save_mappings(mappings):
    log.info("save mappings  count=%d  file=%s", len(mappings), MAPPINGS_FILE)
    save_json(MAPPINGS_FILE, mappings)


# --- OSC helpers (emit to current terminal) ---

def osc_set_colors(theme, reason=None):
    """Emit OSC sequences to apply a full theme to the current terminal."""
    tty_path = os.environ.get("TTY") or "/dev/tty"
    if reason:
        log.info("apply theme  bg=%s fg=%s  tty=%s  reason=%s", theme.get("background"), theme.get("foreground"), tty_path, reason)
    _osc_write_theme(tty_path, theme)


def _osc_write_theme(tty_path, theme):
    """Write OSC sequences for a theme to a tty path."""
    try:
        with open(tty_path, "w") as t:
            t.write(f"\033]11;{theme['background']}\033\\")
            t.write(f"\033]10;{theme['foreground']}\033\\")
            if "cursor-color" in theme:
                t.write(f"\033]12;{theme['cursor-color']}\033\\")
            for idx, color in sorted(theme.get("palette", {}).items()):
                t.write(f"\033]4;{idx};{color}\033\\")
            t.flush()
    except (IOError, OSError):
        pass


def osc_reset(reason=None):
    """Reset terminal colors to Ghostty config defaults."""
    tty = os.environ.get("TTY") or "/dev/tty"
    if reason:
        log.info("reset theme  tty=%s  reason=%s", tty, reason)
    try:
        with open(tty, "w") as t:
            t.write("\033]110\033\\")
            t.write("\033]111\033\\")
            t.write("\033]112\033\\")
            t.write("\033]104\033\\")
            t.flush()
    except (IOError, OSError):
        pass


def _resolve_own_tty():
    """Get the actual tty device path (e.g. /dev/ttys011), not the generic /dev/tty."""
    # $TTY is set by zsh to the real device path
    env_tty = os.environ.get("TTY", "")
    if env_tty and env_tty != "/dev/tty":
        return env_tty
    # Fall back to os.ttyname on stdin/stdout/stderr
    for fd_num in (0, 1, 2):
        try:
            return os.ttyname(fd_num)
        except (OSError, AttributeError):
            continue
    return ""


def broadcast_updates(mappings, themes):
    """Try to update colors in other running Ghostty terminals."""
    # Skip the caller's own tty — it was already set correctly
    own_tty = _resolve_own_tty()
    try:
        result = subprocess.run(
            ["lsof", "-c", "zsh", "+D", "/dev/", "-Fn"],
            capture_output=True, text=True, timeout=3
        )
    except Exception:
        return 0

    ttys = set()
    for line in result.stdout.splitlines():
        if line.startswith("n/dev/ttys") or line.startswith("n/dev/pts/"):
            ttys.add(line[1:])

    # Don't broadcast back to the terminal that just saved
    if own_tty and own_tty in ttys:
        log.info("broadcast  skipping own tty=%s", own_tty)
        ttys.discard(own_tty)

    log.info("broadcast  found %d ttys", len(ttys))
    updated = 0
    for tty_path in ttys:
        try:
            lsof_tty = subprocess.run(
                ["lsof", "-t", tty_path],
                capture_output=True, text=True, timeout=2
            )
            pids = lsof_tty.stdout.strip().splitlines()
            applied = False
            for pid in pids:
                if applied:
                    break
                try:
                    cwd_link = f"/proc/{pid}/cwd"
                    if os.path.exists(cwd_link):
                        cwd = os.readlink(cwd_link)
                    else:
                        lsof_cwd = subprocess.run(
                            ["lsof", "-p", pid, "-Fn", "-d", "cwd"],
                            capture_output=True, text=True, timeout=2
                        )
                        cwd = None
                        for l in lsof_cwd.stdout.splitlines():
                            if l.startswith("n/"):
                                cwd = l[1:]
                        if not cwd:
                            continue

                    for m in mappings:
                        if cwd.startswith(m["directory"]):
                            theme = themes.get(m["theme"])
                            if theme:
                                log.info("broadcast  applying theme=%s to tty=%s (cwd=%s, pid=%s)", m["theme"], tty_path, cwd, pid)
                                _osc_write_theme(tty_path, theme)
                                updated += 1
                                applied = True
                            break
                except (IOError, OSError, subprocess.TimeoutExpired):
                    continue
        except (IOError, OSError, subprocess.TimeoutExpired):
            continue
    return updated


def _hook_theme_block(theme):
    """Generate shell commands to apply a full theme's OSC sequences."""
    cmds = []
    cmds.append(f'printf "\\033]11;{theme["background"]}\\033\\\\"')
    cmds.append(f'printf "\\033]10;{theme["foreground"]}\\033\\\\"')
    if "cursor-color" in theme:
        cmds.append(f'printf "\\033]12;{theme["cursor-color"]}\\033\\\\"')
    for idx, color in sorted(theme.get("palette", {}).items()):
        cmds.append(f'printf "\\033]4;{idx};{color}\\033\\\\"')
    return cmds


def generate_hook():
    """Generate the zsh hook script from current mappings."""
    mappings = load_mappings()
    themes = discover_themes()

    lines = [
        '# Auto-generated by ghostty-dir-themes — do not edit manually',
        '# Sourced from .zshrc to apply per-directory Ghostty themes',
        '',
        '_gdt_reset_theme() {',
        '  printf "\\033]110\\033\\\\"',
        '  printf "\\033]111\\033\\\\"',
        '  printf "\\033]112\\033\\\\"',
        '  printf "\\033]104\\033\\\\"',
        '}',
        '',
        '_gdt_dir_theme() {',
        '  case "$PWD" in',
    ]

    for m in mappings:
        theme = themes.get(m["theme"])
        if theme:
            d = m["directory"].rstrip("/")
            lines.append(f'    {d}*)')
            for cmd in _hook_theme_block(theme):
                lines.append(f'      {cmd}')
            lines.append('      ;;')

    lines += [
        '    *)',
        '      _gdt_reset_theme',
        '      ;;',
        '  esac',
        '}',
        '',
        'if [[ "$TERM_PROGRAM" == "ghostty" ]]; then',
        '  autoload -Uz add-zsh-hook',
        '  add-zsh-hook chpwd _gdt_dir_theme',
        '  _gdt_dir_theme',
        'fi',
        '',
    ]

    with open(HOOK_FILE, "w") as f:
        f.write("\n".join(lines))
    log.info("hook generated  mappings=%d  file=%s", len(mappings), HOOK_FILE)


def batch_fill(root, mappings, theme_names):
    """Add mappings for all immediate subdirectories of root that aren't already mapped."""
    root = os.path.expanduser(root)
    root = os.path.abspath(root)

    try:
        entries = os.listdir(root)
    except OSError:
        return 0

    subdirs = sorted(
        e for e in entries
        if os.path.isdir(os.path.join(root, e)) and not e.startswith(".")
    )

    mapped_dirs = {m["directory"] for m in mappings}
    used_themes = {m["theme"] for m in mappings}

    available = [t for t in theme_names if t not in used_themes]
    random.shuffle(available)

    batch_used = set()
    added = 0
    for subdir in subdirs:
        full_path = os.path.join(root, subdir)
        if full_path in mapped_dirs:
            continue

        if not available:
            refill = [t for t in theme_names if t not in batch_used]
            random.shuffle(refill)
            available = refill

        theme = available.pop() if available else theme_names[0]
        batch_used.add(theme)
        mappings.append({"directory": full_path, "theme": theme})
        added += 1

    return added


# --- Inline picker ---

def _has_more_input(fd, timeout=0.05):
    """Check if there are more bytes pending on fd (for escape sequence detection)."""
    r, _, _ = select.select([fd], [], [], timeout)
    return bool(r)


def run_inline():
    """Lightweight inline theme picker for the current directory."""
    themes = discover_themes()
    theme_names = sorted(themes.keys())
    if not theme_names:
        print("No themes found.")
        return

    mappings = load_mappings()
    cwd = os.getcwd()

    # Find existing mapping for current directory
    idx = 0
    for m in mappings:
        if cwd == m["directory"] or cwd.startswith(m["directory"].rstrip("/") + "/"):
            if m["theme"] in theme_names:
                idx = theme_names.index(m["theme"])
            break

    # Shorten path for display
    home = os.path.expanduser("~")
    display_path = cwd.replace(home, "~") if cwd.startswith(home) else cwd

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)

    # Print initial blank lines to reserve space
    sys.stdout.write("\n\n\n")
    sys.stdout.flush()

    def render():
        name = theme_names[idx]
        counter = f"({idx + 1}/{len(theme_names)})"
        line = f"  \u25c0  {name}  {counter}  \u25b6"
        footer = "  \u2190/\u2192 cycle   Enter save   q/Esc quit"
        sys.stdout.write(f"\033[3A\r\033[K\n\033[K{line}\n\033[K{footer}\n")
        sys.stdout.flush()

    def render_spinner(frame):
        spinner = "\u280b\u2819\u2839\u2838\u283c\u2834\u2826\u2827\u2807\u280f"
        ch = spinner[frame % len(spinner)]
        sys.stdout.write(f"\033[3A\r\033[K\n\033[K  {ch} Saving\u2026\n\033[K\n")
        sys.stdout.flush()

    def clear_and_print(msg):
        sys.stdout.write(f"\033[3A\r\033[K\n\033[K{msg}\n\033[K\n")
        sys.stdout.flush()

    # Find the existing saved theme for this directory (to restore on quit)
    saved_theme = None
    for m in mappings:
        if cwd == m["directory"] or cwd.startswith(m["directory"].rstrip("/") + "/"):
            saved_theme = themes.get(m["theme"])
            break

    def restore_or_reset():
        if saved_theme:
            osc_set_colors(saved_theme, reason="inline-picker restore saved theme")
        else:
            osc_reset(reason="inline-picker restore default")

    try:
        tty.setcbreak(fd)
        log.info("inline picker opened  dir=%s  themes=%d", cwd, len(theme_names))
        osc_set_colors(themes[theme_names[idx]], reason=f"inline-picker preview: {theme_names[idx]}")
        render()

        while True:
            ch = os.read(fd, 1)
            if not ch:
                break
            c = ch[0]

            if c == 0x1b:  # Escape or arrow key
                if _has_more_input(fd):
                    seq = os.read(fd, 2)
                    if seq == b"[D" or seq == b"[h":  # Left
                        idx = (idx - 1) % len(theme_names)
                    elif seq == b"[C" or seq == b"[l":  # Right
                        idx = (idx + 1) % len(theme_names)
                else:
                    # Bare Esc — quit without saving
                    restore_or_reset()
                    log.info("inline picker closed  action=quit-esc")
                    clear_and_print("  gdt quit without saving")
                    return
            elif c == ord("h"):
                idx = (idx - 1) % len(theme_names)
            elif c == ord("l"):
                idx = (idx + 1) % len(theme_names)
            elif c == ord("q"):
                restore_or_reset()
                log.info("inline picker closed  action=quit-q")
                clear_and_print("  gdt quit without saving")
                return
            elif c in (10, 13):  # Enter — save
                chosen = theme_names[idx]
                # Update or add mapping
                found = False
                for m in mappings:
                    if m["directory"] == cwd:
                        m["theme"] = chosen
                        found = True
                        break
                if not found:
                    mappings.append({"directory": cwd, "theme": chosen})

                log.info("inline picker saved  dir=%s  theme=%s", cwd, chosen)

                # Save with spinner
                save_done = threading.Event()
                def _save_worker():
                    save_mappings(mappings)
                    generate_hook()
                    broadcast_updates(mappings, themes)
                    save_done.set()

                thread = threading.Thread(target=_save_worker, daemon=True)
                thread.start()
                frame = 0
                while not save_done.is_set():
                    render_spinner(frame)
                    frame += 1
                    save_done.wait(timeout=0.08)

                clear_and_print(f"  {display_path} \u2192 {chosen}")
                return
            else:
                continue

            osc_set_colors(themes[theme_names[idx]], reason=f"inline-picker preview: {theme_names[idx]}")
            render()
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)


# --- Delete picker ---

def run_delete():
    """Inline picker to delete mappings that apply to the current directory."""
    mappings = load_mappings()
    cwd = os.getcwd()

    # Find all matching mappings: exact and parent matches
    matches = []
    for i, m in enumerate(mappings):
        d = m["directory"].rstrip("/")
        if cwd == m["directory"] or cwd == d:
            matches.append((i, m, "exact"))
        elif cwd.startswith(d + "/"):
            matches.append((i, m, "parent"))

    if not matches:
        print("No mappings for this directory.")
        return

    home = os.path.expanduser("~")
    cursor = 0

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)

    # Reserve 3 lines
    sys.stdout.write("\n\n\n")
    sys.stdout.flush()

    def render():
        _, m, match_type = matches[cursor]
        display_dir = m["directory"].replace(home, "~") if m["directory"].startswith(home) else m["directory"]
        counter = f"({cursor + 1}/{len(matches)})  " if len(matches) > 1 else ""
        line = f"  {display_dir} \u2192 {m['theme']}  {counter}({match_type})"
        footer = "  \u2190/\u2192 cycle   Enter delete   q/Esc quit" if len(matches) > 1 else "  Enter delete   q/Esc quit"
        sys.stdout.write(f"\033[3A\r\033[K\n\033[K{line}\n\033[K{footer}\n")
        sys.stdout.flush()

    def clear_and_print(msg):
        sys.stdout.write(f"\033[3A\r\033[K\n\033[K{msg}\n\033[K\n")
        sys.stdout.flush()

    try:
        tty.setcbreak(fd)
        log.info("delete picker opened  dir=%s  matches=%d", cwd, len(matches))
        render()

        while True:
            ch = os.read(fd, 1)
            if not ch:
                break
            c = ch[0]

            if c == 0x1b:  # Escape or arrow key
                if _has_more_input(fd):
                    seq = os.read(fd, 2)
                    if seq == b"[D" or seq == b"[h":  # Left
                        cursor = (cursor - 1) % len(matches)
                    elif seq == b"[C" or seq == b"[l":  # Right
                        cursor = (cursor + 1) % len(matches)
                    else:
                        continue
                else:
                    log.info("delete picker closed  action=quit-esc")
                    clear_and_print("  gdt quit without deleting")
                    return
            elif c == ord("h"):
                cursor = (cursor - 1) % len(matches)
            elif c == ord("l"):
                cursor = (cursor + 1) % len(matches)
            elif c == ord("q"):
                log.info("delete picker closed  action=quit-q")
                clear_and_print("  gdt quit without deleting")
                return
            elif c in (10, 13):  # Enter — delete
                mapping_idx, m, match_type = matches[cursor]
                display_dir = m["directory"].replace(home, "~") if m["directory"].startswith(home) else m["directory"]
                log.info("delete  dir=%s  theme=%s  match=%s", m["directory"], m["theme"], match_type)
                mappings.pop(mapping_idx)
                save_mappings(mappings)
                generate_hook()
                osc_reset(reason="delete picker removed mapping")
                clear_and_print(f"  Deleted: {display_dir} \u2192 {m['theme']}  ({match_type})")
                return
            else:
                continue

            render()
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)


# --- Curses TUI ---

class TUI:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.themes = discover_themes()
        self.theme_names = sorted(self.themes.keys())
        self.mappings = load_mappings()
        self.cursor = 0
        self.mode = "main"  # main, add_dir, batch_dir, carousel
        self.input_buf = ""
        self.carousel_idx = 0
        self.status = ""
        self.dirty = False
        self.original_mappings = json.dumps(self.mappings)
        self.scroll_offset = 0
        self._save_frame = 0
        self._save_result = None

    def run(self):
        curses.curs_set(0)
        curses.use_default_colors()
        self.stdscr.timeout(-1)
        self.stdscr.keypad(True)
        log.info("TUI opened  mappings=%d  themes=%d", len(self.mappings), len(self.theme_names))
        self.preview_current_mapping()

        while True:
            self.draw()
            key = self.stdscr.getch()

            if self.mode == "main":
                if not self.handle_main(key):
                    break
            elif self.mode == "add_dir":
                self.handle_add_dir(key)
            elif self.mode == "batch_dir":
                self.handle_batch_dir(key)
            elif self.mode == "carousel":
                self.handle_carousel(key)

        # On exit: save if dirty, generate hook, reset preview
        if self.dirty:
            save_mappings(self.mappings)
            generate_hook()
            log.info("TUI closed  action=save  mappings=%d", len(self.mappings))
            self.status = "Saved."
        else:
            log.info("TUI closed  action=quit  dirty=False")
        osc_reset(reason="TUI exit")

    def draw(self):
        self.stdscr.erase()
        h, w = self.stdscr.getmaxyx()

        saving = self.mode == "saving"
        dim = curses.A_DIM if saving else 0

        # Title
        title = " ghostty-dir-themes "
        title_attr = (curses.A_DIM) if saving else (curses.A_BOLD | curses.A_REVERSE)
        self.stdscr.addstr(0, max(0, (w - len(title)) // 2), title, title_attr)

        # Column headers
        y = 2
        hdr = f"  {'Directory':<45} {'Theme':<20}"
        self.stdscr.addstr(y, 0, hdr[:w-1], curses.A_DIM)
        self.stdscr.addstr(y + 1, 0, "─" * min(70, w - 1), curses.A_DIM)
        y += 2

        # Mappings list
        page_size = self._page_size()
        if not self.mappings:
            self.stdscr.addstr(y, 2, "(no mappings — press 'a' to add one)", curses.A_DIM)
            y += 1
        else:
            end = min(len(self.mappings), self.scroll_offset + page_size)
            for i in range(self.scroll_offset, end):
                m = self.mappings[i]
                prefix = "▸ " if i == self.cursor else "  "
                attr = curses.A_DIM if saving else (curses.A_BOLD if i == self.cursor else 0)

                # If in carousel mode on this row, show carousel state
                if self.mode == "carousel" and i == self.cursor:
                    tname = self.theme_names[self.carousel_idx]
                    line = f"{prefix}{m['directory']:<45} ◀ {tname:<16} ▶"
                    self.stdscr.addstr(y, 0, line[:w-1], attr | curses.A_REVERSE)
                else:
                    line = f"{prefix}{m['directory']:<45} {m['theme']:<20}"
                    self.stdscr.addstr(y, 0, line[:w-1], attr)
                y += 1

            # Page indicator
            total_pages = (len(self.mappings) + page_size - 1) // page_size
            if total_pages > 1:
                current_page = self.scroll_offset // page_size + 1
                indicator = f"Page {current_page}/{total_pages}  (←→ page, ↑↓ navigate)"
                self.stdscr.addstr(y, 2, indicator[:w-3], curses.A_DIM)

        # Saving overlay
        if saving:
            spinner = "⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
            frame = spinner[self._save_frame % len(spinner)]
            msg = f" {frame} Saving & broadcasting… "
            cy = h // 2
            cx = max(0, (w - len(msg)) // 2)
            self.stdscr.addstr(cy, cx, msg, curses.A_BOLD)

        # Status bar
        status_y = h - 3
        if self.status:
            self.stdscr.addstr(status_y, 0, self.status[:w-1], curses.A_DIM)

        # Mode-specific footer
        footer_y = h - 1
        if self.mode == "saving":
            foot = " Saving… please wait "
            self.stdscr.addstr(footer_y, 0, foot[:w-1], curses.A_DIM | curses.A_REVERSE)
        elif self.mode == "main":
            total_pages = (max(len(self.mappings), 1) + page_size - 1) // page_size
            if total_pages > 1:
                foot = " ↑↓ Navigate  ←→ Page  a Add  b Batch  d Delete  Enter Edit theme  s Save  q Quit "
            else:
                foot = " ↑↓ Navigate  a Add  b Batch  d Delete  Enter Edit theme  s Save  q Quit "
            self.stdscr.addstr(footer_y, 0, foot[:w-1], curses.A_REVERSE)
        elif self.mode in ("add_dir", "batch_dir"):
            label = "Directory path" if self.mode == "add_dir" else "Batch root"
            prompt = f" {label}: {self.input_buf}█ "
            self.stdscr.addstr(footer_y, 0, prompt[:w-1], curses.A_REVERSE)
        elif self.mode == "carousel":
            foot = " ◀▶ Cycle themes  Enter Confirm  Esc Cancel "
            self.stdscr.addstr(footer_y, 0, foot[:w-1], curses.A_REVERSE)

        self.stdscr.refresh()

    def preview_current_mapping(self):
        """Preview the theme for the currently selected mapping."""
        if self.mappings:
            tname = self.mappings[self.cursor]["theme"]
            theme = self.themes.get(tname)
            if theme:
                osc_set_colors(theme, reason=f"TUI preview: {tname}")

    def _page_size(self):
        h, _ = self.stdscr.getmaxyx()
        return max(1, h - 8)

    def _ensure_cursor_visible(self):
        ps = self._page_size()
        if self.cursor < self.scroll_offset:
            self.scroll_offset = self.cursor
        elif self.cursor >= self.scroll_offset + ps:
            self.scroll_offset = self.cursor - ps + 1

    def do_save_async(self):
        """Run save/hook/broadcast in a background thread with spinner."""
        self._save_frame = 0
        self._save_result = None
        self.mode = "saving"

        def _worker():
            save_mappings(self.mappings)
            generate_hook()
            count = broadcast_updates(self.mappings, self.themes)
            self._save_result = count

        thread = threading.Thread(target=_worker, daemon=True)
        thread.start()

        self.stdscr.timeout(80)
        while thread.is_alive():
            self.draw()
            self._save_frame += 1
            self.stdscr.getch()  # discard input during save
        self.stdscr.timeout(-1)

        self.dirty = False
        self.mode = "main"
        count = self._save_result or 0
        log.info("TUI save complete  broadcast=%d terminals", count)
        self.status = f"Saved & hook regenerated. Broadcast to {count} terminal(s)."

    def handle_main(self, key):
        if key == ord("q"):
            return False
        elif key == ord("s"):
            self.do_save_async()
        elif key == curses.KEY_UP:
            if self.mappings:
                self.cursor = max(0, self.cursor - 1)
                self._ensure_cursor_visible()
                self.preview_current_mapping()
        elif key == curses.KEY_DOWN:
            if self.mappings:
                self.cursor = min(len(self.mappings) - 1, self.cursor + 1)
                self._ensure_cursor_visible()
                self.preview_current_mapping()
        elif key == curses.KEY_LEFT:
            if self.mappings:
                self.cursor = max(0, self.cursor - self._page_size())
                self._ensure_cursor_visible()
                self.preview_current_mapping()
        elif key == curses.KEY_RIGHT:
            if self.mappings:
                self.cursor = min(len(self.mappings) - 1, self.cursor + self._page_size())
                self._ensure_cursor_visible()
                self.preview_current_mapping()
        elif key == ord("a"):
            self.mode = "add_dir"
            self.input_buf = ""
            self.status = "Enter directory path (tab to complete, enter to confirm)"
            curses.curs_set(1)
        elif key == ord("b"):
            self.mode = "batch_dir"
            self.input_buf = ""
            self.status = "Enter root directory to batch-fill (tab to complete)"
            curses.curs_set(1)
        elif key == ord("d"):
            if self.mappings:
                removed = self.mappings.pop(self.cursor)
                self.cursor = min(self.cursor, max(0, len(self.mappings) - 1))
                self._ensure_cursor_visible()
                self.dirty = True
                log.info("TUI delete mapping  dir=%s  theme=%s", removed["directory"], removed["theme"])
                self.status = f"Removed: {removed['directory']}"
        elif key in (ord("\n"), curses.KEY_ENTER, 10, 13, ord("e")):
            if self.mappings:
                self.enter_carousel()
        return True

    def enter_carousel(self):
        if not self.theme_names:
            self.status = "No themes available. Run 'gdt --fetch-themes' to download themes."
            return
        self.mode = "carousel"
        current_theme = self.mappings[self.cursor]["theme"]
        if current_theme in self.theme_names:
            self.carousel_idx = self.theme_names.index(current_theme)
        else:
            self.carousel_idx = 0
        self.preview_carousel_theme()

    def preview_carousel_theme(self):
        tname = self.theme_names[self.carousel_idx]
        theme = self.themes[tname]
        osc_set_colors(theme, reason=f"TUI carousel preview: {tname}")
        self.status = f"Preview: {tname}  ({self.carousel_idx + 1}/{len(self.theme_names)})"

    def handle_carousel(self, key):
        if key in (curses.KEY_LEFT, ord("h")):
            self.carousel_idx = (self.carousel_idx - 1) % len(self.theme_names)
            self.preview_carousel_theme()
        elif key in (curses.KEY_RIGHT, ord("l")):
            self.carousel_idx = (self.carousel_idx + 1) % len(self.theme_names)
            self.preview_carousel_theme()
        elif key in (ord("\n"), curses.KEY_ENTER, 10, 13):
            tname = self.theme_names[self.carousel_idx]
            dir_path = self.mappings[self.cursor]["directory"]
            self.mappings[self.cursor]["theme"] = tname
            self.dirty = True
            self.mode = "main"
            log.info("TUI carousel set  dir=%s  theme=%s", dir_path, tname)
            self.preview_current_mapping()
            self.status = f"Set theme: {tname}"
        elif key == 27:  # Esc
            self.mode = "main"
            osc_reset(reason="TUI carousel cancel")
            self.status = "Cancelled."

    def handle_add_dir(self, key):
        if key in (ord("\n"), curses.KEY_ENTER, 10, 13):
            curses.curs_set(0)
            path = self.input_buf.strip()
            if not path:
                self.mode = "main"
                self.status = "Cancelled (empty path)."
                return

            path = os.path.expanduser(path)
            if not os.path.isabs(path):
                path = os.path.abspath(path)

            # Check for duplicate
            for m in self.mappings:
                if m["directory"] == path:
                    self.mode = "main"
                    self.status = f"Already mapped: {path}"
                    return

            self.mappings.append({"directory": path, "theme": self.theme_names[0]})
            self.cursor = len(self.mappings) - 1
            self._ensure_cursor_visible()
            self.dirty = True
            self.mode = "main"
            self.status = f"Added: {path} — press Enter to pick a theme"

        elif key == 27:  # Esc
            curses.curs_set(0)
            self.mode = "main"
            self.status = "Cancelled."

        elif key == 9:  # Tab — basic path completion
            partial = os.path.expanduser(self.input_buf)
            matches = glob.glob(partial + "*")
            dirs = [m + "/" for m in matches if os.path.isdir(m)]
            if len(dirs) == 1:
                self.input_buf = dirs[0]
            elif len(dirs) > 1:
                # Find common prefix
                prefix = os.path.commonprefix(dirs)
                self.input_buf = prefix
                self.status = f"{len(dirs)} matches"

        elif key in (curses.KEY_BACKSPACE, 127, 8):
            self.input_buf = self.input_buf[:-1]

        elif 32 <= key <= 126:
            self.input_buf += chr(key)


    def handle_batch_dir(self, key):
        if key in (ord("\n"), curses.KEY_ENTER, 10, 13):
            curses.curs_set(0)
            path = self.input_buf.strip()
            if not path:
                self.mode = "main"
                self.status = "Cancelled (empty path)."
                return

            path = os.path.expanduser(path)
            if not os.path.isabs(path):
                path = os.path.abspath(path)

            if not os.path.isdir(path):
                self.mode = "main"
                self.status = f"Not a directory: {path}"
                return

            count = batch_fill(path, self.mappings, self.theme_names)
            if count > 0:
                self.cursor = len(self.mappings) - 1
                self._ensure_cursor_visible()
                self.dirty = True
            self.mode = "main"
            display_path = path.replace(os.path.expanduser("~"), "~")
            self.status = f"Added {count} directories from {display_path}"

        elif key == 27:  # Esc
            curses.curs_set(0)
            self.mode = "main"
            self.status = "Cancelled."

        elif key == 9:  # Tab — basic path completion
            partial = os.path.expanduser(self.input_buf)
            matches = glob.glob(partial + "*")
            dirs = [m + "/" for m in matches if os.path.isdir(m)]
            if len(dirs) == 1:
                self.input_buf = dirs[0]
            elif len(dirs) > 1:
                prefix = os.path.commonprefix(dirs)
                self.input_buf = prefix
                self.status = f"{len(dirs)} matches"

        elif key in (curses.KEY_BACKSPACE, 127, 8):
            self.input_buf = self.input_buf[:-1]

        elif 32 <= key <= 126:
            self.input_buf += chr(key)


def main():
    parser = argparse.ArgumentParser(description="Manage per-directory Ghostty color themes")
    parser.add_argument("--generate-hook", action="store_true", help="Regenerate hook.zsh and exit")
    parser.add_argument("--fetch-themes", action="store_true", help="Download ~460 Ghostty themes from GitHub")
    parser.add_argument("--refresh", action="store_true", help="Reapply the theme for the current directory")
    parser.add_argument("--delete", action="store_true", help="Delete a mapping for the current directory")
    parser.add_argument("--all", action="store_true", help="Open full-screen TUI to manage all mappings")
    parser.add_argument("--version", action="store_true", help="Print version and exit")
    args = parser.parse_args()

    if args.version:
        print(f"gdt {VERSION}")
        return

    os.makedirs(CONFIG_DIR, exist_ok=True)
    maybe_migrate()

    if args.fetch_themes:
        fetch_themes()

    if args.refresh:
        mappings = load_mappings()
        cwd = os.getcwd()
        for m in mappings:
            if cwd == m["directory"] or cwd.startswith(m["directory"].rstrip("/") + "/"):
                themes = discover_themes()
                theme = themes.get(m["theme"])
                if theme:
                    osc_set_colors(theme, reason=f"refresh: {m['theme']} for {cwd}")
                    return
        osc_reset(reason=f"refresh: no mapping for {cwd}")
        return

    if args.generate_hook:
        generate_hook()
        print(f"Generated: {HOOK_FILE}")
        return

    if args.delete:
        run_delete()
        return

    # Ensure mappings file exists
    if not os.path.exists(MAPPINGS_FILE):
        save_mappings([])

    # Auto-fetch if no themes available
    if not discover_themes():
        fetch_themes()

    if args.all:
        def run_tui(stdscr):
            tui = TUI(stdscr)
            tui.run()
        curses.wrapper(run_tui)
    else:
        run_inline()


if __name__ == "__main__":
    main()
